algo its self
1) Parsing era (done)
2) if one philo handle it
3) create all philos and threads
4) create the monitor (main thread)
5) start simulation (synchronisation)
6) join everything


Routine of philosophers :

So in our loop, they will eat, sleep and think. Let's start with the easiest one when they think we 
just need to print a message "X is thinking" (X is the philo number), When they sleep we need to make them sleep 
the length of the input inserted by the user using our ft_usleep (described in the bottom of this page) 
and then print the message "X is sleeping". Now to the eating part,
We will lock the right fork first using pthread_mutex_lock and print the message, and do the same with the left fork.
Then he will eat using ft_usleep again and only then he will drop the forks by unlocking the locks, 
before that we change some variables that give our monitor indications but that's the general idea.

Monitor :

This thread will be running and monitoring the whole program, it has 2 checks in it that run infinitely until a philo dies or they all ate the number of meals they need to (last input argument). Basically, we will check that the time a philo needs to die didn't surpass the last meal he had and that he is not concurrently eating. If he indeed died we change the dead flag to 1 and that will break the loop in all of the threads. The other check is to see if all the philos finished eating the amount of meals they need to, and if they did we will again change the dead flag to one and break the threads loop.
